{"version":3,"file":"static/js/687.a627dadd.chunk.js","mappings":"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","sources":["pages/Analysis/Binance/BinanceHeatmap.js","../node_modules/react-use-websocket/src/index.ts","../node_modules/react-use-websocket/src/lib/attach-listener.ts","../node_modules/react-use-websocket/src/lib/attach-shared-listeners.ts","../node_modules/react-use-websocket/src/lib/constants.ts","../node_modules/react-use-websocket/src/lib/create-or-join.ts","../node_modules/react-use-websocket/src/lib/get-url.ts","../node_modules/react-use-websocket/src/lib/globals.ts","../node_modules/react-use-websocket/src/lib/manage-subscribers.ts","../node_modules/react-use-websocket/src/lib/proxy.ts","../node_modules/react-use-websocket/src/lib/socket-io.ts","../node_modules/react-use-websocket/src/lib/use-event-source.ts","../node_modules/react-use-websocket/src/lib/use-socket-io.ts","../node_modules/react-use-websocket/src/lib/use-websocket.ts","../node_modules/react-use-websocket/src/lib/util.ts"],"sourcesContent":["import { useEffect, useState } from \"react\";\nimport React from \"react\";\nimport useWebSocket from \"react-use-websocket\";\n\nconst productionUrl = window.location.origin.replace(\"https\", \"wss\");\nconst socketUrl =\n  process.env.NODE_ENV === \"production\" ? productionUrl : \"ws://127.0.0.1:3000\";\nconsole.log(\"socketUrl\", socketUrl);\n\nconst BinanceHeatmap = () => {\n  const { sendMessage, lastMessage, readyState } = useWebSocket(socketUrl, {\n    share: true,\n    retryOnError: true,\n    reconnectAttempts: 1000,\n    reconnectInterval: 3000,\n    //Will attempt to reconnect on all close events, such as server shutting down\n    shouldReconnect: () => true,\n    onOpen: (event) => console.log(\"opened ws\", event),\n    onClose: (closeEvent) => console.log(\"ws closed\", closeEvent),\n    onError: (errEvent) => console.log(\"error\", errEvent),\n    onReconnectStop: (numAttemp) => console.log(\"reconnect stopped\", numAttemp),\n  });\n  const [binanceHeatmap, $binanceHeatmap] = useState({});\n  useEffect(() => {\n    if (lastMessage !== null) {\n      console.log(\"lastMessage\", lastMessage);\n      const json = JSON.parse(lastMessage.data);\n      // console.log(\"binanceHeatmap\", json);\n      $binanceHeatmap(json);\n      // try ping server\n      sendMessage(JSON.stringify({ message: \"ws ping\" }));\n    }\n  }, [lastMessage]);\n\n  return (\n    <>\n      <h1>Binance Heatmap</h1>\n      <div className=\"row\">\n        <div className=\"column\">\n          <h2>24h Change</h2>\n          {readyState &&\n            binanceHeatmap.change24Hs?.slice(0, 10).map((contract, idx) => {\n              return (\n                <h4 key={idx}>\n                  <span>{contract.symbol}</span>\n                  <span> : {contract.priceChangePercent}</span>\n                </h4>\n              );\n            })}\n        </div>\n        <div className=\"column\">\n          <h2>Trading Volume</h2>\n          {readyState &&\n            binanceHeatmap.tradingVol24H?.slice(0, 10).map((contract, idx) => {\n              return (\n                <h4 key={idx}>\n                  <span>{contract.symbol}</span>\n                  <span> : ${contract.quoteVolume}</span>\n                </h4>\n              );\n            })}\n        </div>\n        <div className=\"column\">\n          <h2>Funding Rates</h2>\n          {binanceHeatmap.fundingRates?.slice(0, 10).map((contract, idx) => {\n            return (\n              <h4 key={idx}>\n                <span>{contract.symbol}</span>\n                <span> : {contract.fundingRate}</span>\n              </h4>\n            );\n          })}\n        </div>\n      </div>\n    </>\n  );\n};\n\nexport default BinanceHeatmap;\n","export { useWebSocket as default } from './lib/use-websocket';\n\nexport { SendMessage, Options } from './lib/types';\n\nexport { useSocketIO } from './lib/use-socket-io';\n\nexport { ReadyState } from './lib/constants';\n\nexport { useEventSource } from './lib/use-event-source';\n\nexport { resetGlobalState } from './lib/util';\n","import { MutableRefObject } from 'react';\nimport { setUpSocketIOPing } from './socket-io';\nimport {\n  DEFAULT_RECONNECT_LIMIT,\n  DEFAULT_RECONNECT_INTERVAL_MS,\n  ReadyState,\n  isEventSourceSupported,\n} from './constants';\nimport { Options, SendMessage, WebSocketLike } from './types';\nimport { assertIsWebSocket } from './util';\n\nexport interface Setters {\n  setLastMessage: (message: WebSocketEventMap['message']) => void;\n  setReadyState: (readyState: ReadyState) => void;\n}\n\nconst bindMessageHandler = (\n  webSocketInstance: WebSocketLike,\n  optionsRef: MutableRefObject<Options>,\n  setLastMessage: Setters['setLastMessage'],\n) => {\n  webSocketInstance.onmessage = (message: WebSocketEventMap['message']) => {\n    optionsRef.current.onMessage && optionsRef.current.onMessage(message);\n    if (typeof optionsRef.current.filter === 'function' && optionsRef.current.filter(message) !== true) {\n      return;\n    }\n    setLastMessage(message);\n  };\n};\n\nconst bindOpenHandler = (\n  webSocketInstance: WebSocketLike,\n  optionsRef: MutableRefObject<Options>,\n  setReadyState: Setters['setReadyState'],\n  reconnectCount: MutableRefObject<number>,\n) => {\n  webSocketInstance.onopen = (event: WebSocketEventMap['open']) => {\n    optionsRef.current.onOpen && optionsRef.current.onOpen(event);\n    reconnectCount.current = 0;\n    setReadyState(ReadyState.OPEN);\n  };\n};\n\nconst bindCloseHandler = (\n  webSocketInstance: WebSocketLike,\n  optionsRef: MutableRefObject<Options>,\n  setReadyState: Setters['setReadyState'],\n  reconnect: () => void,\n  reconnectCount: MutableRefObject<number>,\n) => {\n  if (isEventSourceSupported && webSocketInstance instanceof EventSource) {\n    return () => {};\n  }\n  assertIsWebSocket(webSocketInstance, optionsRef.current.skipAssert);\n  let reconnectTimeout: number;\n\n  webSocketInstance.onclose = (event: WebSocketEventMap['close']) => {\n    optionsRef.current.onClose && optionsRef.current.onClose(event);\n    setReadyState(ReadyState.CLOSED);\n    if (optionsRef.current.shouldReconnect && optionsRef.current.shouldReconnect(event)) {\n      const reconnectAttempts = optionsRef.current.reconnectAttempts ?? DEFAULT_RECONNECT_LIMIT;\n      if (reconnectCount.current < reconnectAttempts) {\n        const nextReconnectInterval = typeof optionsRef.current.reconnectInterval === 'function' ?\n          optionsRef.current.reconnectInterval(reconnectCount.current) :\n          optionsRef.current.reconnectInterval;\n\n        reconnectTimeout = window.setTimeout(() => {\n          reconnectCount.current++;\n          reconnect();\n        }, nextReconnectInterval ?? DEFAULT_RECONNECT_INTERVAL_MS);\n      } else {\n        optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(reconnectAttempts);\n        console.warn(`Max reconnect attempts of ${reconnectAttempts} exceeded`);\n      }\n    }\n  };\n\n  return () => reconnectTimeout && window.clearTimeout(reconnectTimeout);\n};\n\nconst bindErrorHandler = (\n  webSocketInstance: WebSocketLike,\n  optionsRef: MutableRefObject<Options>,\n  setReadyState: Setters['setReadyState'],\n  reconnect: () => void,\n  reconnectCount: MutableRefObject<number>,\n) => {\n  let reconnectTimeout: number;\n\n  webSocketInstance.onerror = (error: WebSocketEventMap['error']) => {\n    optionsRef.current.onError && optionsRef.current.onError(error);\n    if (isEventSourceSupported && webSocketInstance instanceof EventSource) {\n      optionsRef.current.onClose && optionsRef.current.onClose({\n        ...error,\n        code: 1006,\n        reason: `An error occurred with the EventSource: ${error}`,\n        wasClean: false,\n      });\n\n      setReadyState(ReadyState.CLOSED);\n      webSocketInstance.close();\n    }\n    \n    if (optionsRef.current.retryOnError) {\n      if (reconnectCount.current < (optionsRef.current.reconnectAttempts ?? DEFAULT_RECONNECT_LIMIT)) {\n        const nextReconnectInterval = typeof optionsRef.current.reconnectInterval === 'function' ?\n          optionsRef.current.reconnectInterval(reconnectCount.current) :\n          optionsRef.current.reconnectInterval;\n\n        reconnectTimeout = window.setTimeout(() => {\n          reconnectCount.current++;\n          reconnect();\n        }, nextReconnectInterval ?? DEFAULT_RECONNECT_INTERVAL_MS);\n      } else {\n        optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(optionsRef.current.reconnectAttempts as number);\n        console.warn(`Max reconnect attempts of ${optionsRef.current.reconnectAttempts} exceeded`);\n      }\n    }\n  };\n\n  return () => reconnectTimeout && window.clearTimeout(reconnectTimeout);\n};\n\nexport const attachListeners = (\n    webSocketInstance: WebSocketLike,\n    setters: Setters,\n    optionsRef: MutableRefObject<Options>,\n    reconnect: () => void,\n    reconnectCount: MutableRefObject<number>,\n    sendMessage: SendMessage,\n  ): (() => void) => {\n  const { setLastMessage, setReadyState } = setters;\n\n  let interval: number;\n  let cancelReconnectOnClose: () => void;\n  let cancelReconnectOnError: () => void;\n\n  if (optionsRef.current.fromSocketIO) {\n    interval = setUpSocketIOPing(sendMessage);\n  }\n\n  bindMessageHandler(\n    webSocketInstance,\n    optionsRef,\n    setLastMessage,\n  );\n\n  bindOpenHandler(\n    webSocketInstance,\n    optionsRef,\n    setReadyState,\n    reconnectCount,\n  );\n\n  cancelReconnectOnClose = bindCloseHandler(\n    webSocketInstance,\n    optionsRef,\n    setReadyState,\n    reconnect,\n    reconnectCount,\n  );\n\n  cancelReconnectOnError = bindErrorHandler(\n    webSocketInstance,\n    optionsRef,\n    setReadyState,\n    reconnect,\n    reconnectCount,\n  );\n\n  return () => {\n    setReadyState(ReadyState.CLOSING);\n    cancelReconnectOnClose();\n    cancelReconnectOnError();\n    webSocketInstance.close();\n    if (interval) clearInterval(interval);\n  };\n};\n","import { sharedWebSockets } from './globals';\nimport { DEFAULT_RECONNECT_LIMIT, DEFAULT_RECONNECT_INTERVAL_MS, ReadyState, isEventSourceSupported } from './constants';\nimport { getSubscribers } from './manage-subscribers';\nimport { MutableRefObject } from 'react';\nimport { Options, SendMessage, WebSocketLike } from './types';\nimport { setUpSocketIOPing } from './socket-io';\n\nconst bindMessageHandler = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n) => {\n  webSocketInstance.onmessage = (message: WebSocketEventMap['message']) => {\n    getSubscribers(url).forEach(subscriber => {\n      if (subscriber.optionsRef.current.onMessage) {\n        subscriber.optionsRef.current.onMessage(message);\n      }\n\n      if (\n        typeof subscriber.optionsRef.current.filter === 'function' &&\n        subscriber.optionsRef.current.filter(message) !== true\n      ) {\n        return;\n      }\n\n      subscriber.setLastMessage(message);\n    });\n  };\n};\n\nconst bindOpenHandler = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n) => {\n  webSocketInstance.onopen = (event: WebSocketEventMap['open']) => {\n    getSubscribers(url).forEach(subscriber => {\n      subscriber.reconnectCount.current = 0;\n      if (subscriber.optionsRef.current.onOpen) {\n        subscriber.optionsRef.current.onOpen(event);\n      }\n\n      subscriber.setReadyState(ReadyState.OPEN);\n    });\n  };\n};\n\nconst bindCloseHandler = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n) => {\n  if (webSocketInstance instanceof WebSocket) {\n    webSocketInstance.onclose = (event: WebSocketEventMap['close']) => {\n      getSubscribers(url).forEach(subscriber => {\n        if (subscriber.optionsRef.current.onClose) {\n          subscriber.optionsRef.current.onClose(event);\n        }\n  \n        subscriber.setReadyState(ReadyState.CLOSED);\n      });\n      \n      delete sharedWebSockets[url];\n  \n      getSubscribers(url).forEach(subscriber => {\n        if (\n          subscriber.optionsRef.current.shouldReconnect &&\n          subscriber.optionsRef.current.shouldReconnect(event)\n        ) {\n          const reconnectAttempts = subscriber.optionsRef.current.reconnectAttempts ?? DEFAULT_RECONNECT_LIMIT;\n          if (subscriber.reconnectCount.current < reconnectAttempts) {\n            const nextReconnectInterval = typeof subscriber.optionsRef.current.reconnectInterval === 'function' ?\n              subscriber.optionsRef.current.reconnectInterval(subscriber.reconnectCount.current) :\n              subscriber.optionsRef.current.reconnectInterval;\n\n            setTimeout(() => {\n              subscriber.reconnectCount.current++;\n              subscriber.reconnect.current();\n            }, nextReconnectInterval ?? DEFAULT_RECONNECT_INTERVAL_MS);\n          } else {\n            subscriber.optionsRef.current.onReconnectStop && subscriber.optionsRef.current.onReconnectStop(subscriber.optionsRef.current.reconnectAttempts as number);\n            console.warn(`Max reconnect attempts of ${reconnectAttempts} exceeded`);\n          }\n        }\n      });\n    };\n  }\n};\n\nconst bindErrorHandler = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n) => {\n  webSocketInstance.onerror = (error: WebSocketEventMap['error']) => {\n    getSubscribers(url).forEach(subscriber => {\n      if (subscriber.optionsRef.current.onError) {\n        subscriber.optionsRef.current.onError(error);\n      }\n      if (isEventSourceSupported && webSocketInstance instanceof EventSource) {\n        subscriber.optionsRef.current.onClose && subscriber.optionsRef.current.onClose({\n          ...error,\n          code: 1006,\n          reason: `An error occurred with the EventSource: ${error}`,\n          wasClean: false,\n        });\n  \n        subscriber.setReadyState(ReadyState.CLOSED);\n      }\n    });\n    if (isEventSourceSupported && webSocketInstance instanceof EventSource) {\n      webSocketInstance.close();\n    }\n  };\n};\n\nexport const attachSharedListeners = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n  optionsRef: MutableRefObject<Options>,\n  sendMessage: SendMessage,\n) => {\n  let interval: number;\n\n  if (optionsRef.current.fromSocketIO) {\n    interval = setUpSocketIOPing(sendMessage);\n  }\n\n  bindMessageHandler(webSocketInstance, url);\n  bindCloseHandler(webSocketInstance, url);\n  bindOpenHandler(webSocketInstance, url);\n  bindErrorHandler(webSocketInstance, url);\n\n  return () => {\n    if (interval) clearInterval(interval);\n  };\n};\n","import { EventSourceEventHandlers, EventSourceOptions } from \"./types\";\n\nconst MILLISECONDS = 1;\nconst SECONDS = 1000 * MILLISECONDS;\n\nexport const DEFAULT_OPTIONS = {};\nexport const EMPTY_EVENT_HANDLERS: EventSourceEventHandlers = {};\nexport const DEFAULT_EVENT_SOURCE_OPTIONS: EventSourceOptions = {\n  withCredentials: false,\n  events: EMPTY_EVENT_HANDLERS,\n};\nexport const SOCKET_IO_PING_INTERVAL = 25 * SECONDS;\nexport const SOCKET_IO_PATH = '/socket.io/?EIO=3&transport=websocket';\nexport const SOCKET_IO_PING_CODE = '2';\nexport const DEFAULT_RECONNECT_LIMIT = 20;\nexport const DEFAULT_RECONNECT_INTERVAL_MS = 5000;\nexport const UNPARSABLE_JSON_OBJECT = {};\n\nexport enum ReadyState {\n  UNINSTANTIATED = -1,\n  CONNECTING = 0,\n  OPEN = 1,\n  CLOSING = 2,\n  CLOSED = 3,\n}\n\nconst eventSourceSupported = () => {\n  try {\n    return 'EventSource' in globalThis;\n  } catch (e) {\n    return false;\n  }\n}\n\nexport const isReactNative = typeof navigator !== 'undefined' && navigator.product === 'ReactNative';\nexport const isEventSourceSupported = !isReactNative && eventSourceSupported();\n","import { MutableRefObject } from 'react';\nimport { sharedWebSockets } from './globals';\nimport { Options, SendMessage, Subscriber, WebSocketLike } from './types';\nimport { isEventSourceSupported, ReadyState, isReactNative } from './constants';\nimport { attachListeners } from './attach-listener';\nimport { attachSharedListeners } from './attach-shared-listeners';\nimport { addSubscriber, removeSubscriber, hasSubscribers } from './manage-subscribers';\n\n//TODO ensure that all onClose callbacks are called\n\nconst cleanSubscribers = (\n  url: string,\n  subscriber: Subscriber,\n  optionsRef: MutableRefObject<Options>,\n  setReadyState: (readyState: ReadyState) => void,\n  clearSocketIoPingInterval: (() => void) | null,\n) => {\n  return () => {\n    removeSubscriber(url, subscriber);\n    if (!hasSubscribers(url)) {\n      try {\n        const socketLike = sharedWebSockets[url];\n        if (socketLike instanceof WebSocket) {\n          socketLike.onclose = (event: WebSocketEventMap['close']) => {\n            if (optionsRef.current.onClose) {\n              optionsRef.current.onClose(event);\n            }\n            setReadyState(ReadyState.CLOSED);\n          };\n        }\n        socketLike.close();\n      } catch (e) {\n\n      }\n      if (clearSocketIoPingInterval) clearSocketIoPingInterval();\n\n      delete sharedWebSockets[url];\n    }\n  }\n};\n\nexport const createOrJoinSocket = (\n  webSocketRef: MutableRefObject<WebSocketLike | null>,\n  url: string,\n  setReadyState: (readyState: ReadyState) => void,\n  optionsRef: MutableRefObject<Options>,\n  setLastMessage: (message: WebSocketEventMap['message']) => void,\n  startRef: MutableRefObject<() => void>,\n  reconnectCount: MutableRefObject<number>,\n  sendMessage: SendMessage,\n): (() => void) => {\n  if (!isEventSourceSupported && optionsRef.current.eventSourceOptions) {\n    if (isReactNative) {\n      throw new Error('EventSource is not supported in ReactNative');\n    } else {\n      throw new Error('EventSource is not supported');\n    }\n  }\n\n  if (optionsRef.current.share) {\n    let clearSocketIoPingInterval: ((() => void) | null) = null;\n    if (sharedWebSockets[url] === undefined) {\n      sharedWebSockets[url] = optionsRef.current.eventSourceOptions ?\n        new EventSource(url, optionsRef.current.eventSourceOptions) :\n        new WebSocket(url, optionsRef.current.protocols);\n      webSocketRef.current = sharedWebSockets[url];\n      setReadyState(ReadyState.CONNECTING);\n      clearSocketIoPingInterval = attachSharedListeners(\n        sharedWebSockets[url],\n        url,\n        optionsRef,\n        sendMessage,\n      );\n    } else {\n      webSocketRef.current = sharedWebSockets[url];\n      setReadyState(sharedWebSockets[url].readyState);\n    }\n\n    const subscriber: Subscriber = {\n      setLastMessage,\n      setReadyState,\n      optionsRef,\n      reconnectCount,\n      reconnect: startRef,\n    };\n  \n    addSubscriber(url, subscriber);\n\n    return cleanSubscribers(\n      url,\n      subscriber,\n      optionsRef,\n      setReadyState,\n      clearSocketIoPingInterval,\n    );\n  } else {\n    webSocketRef.current = optionsRef.current.eventSourceOptions ?\n      new EventSource(url, optionsRef.current.eventSourceOptions) :\n      new WebSocket(url, optionsRef.current.protocols);\n    setReadyState(ReadyState.CONNECTING);\n    if (!webSocketRef.current) {\n      throw new Error('WebSocket failed to be created');\n    }\n\n    return attachListeners(\n      webSocketRef.current,\n      {\n        setLastMessage,\n        setReadyState\n      },\n      optionsRef,\n      startRef.current,\n      reconnectCount,\n      sendMessage,\n    );\n  }\n};\n","import { MutableRefObject } from 'react';\nimport { parseSocketIOUrl, appendQueryParams } from './socket-io';\nimport { Options } from './types';\n\nexport const getUrl = async (\n  url: string | (() => string | Promise<string>),\n  optionsRef: MutableRefObject<Options>,\n) => {\n  let convertedUrl: string;\n\n  if (typeof url === 'function') {\n    convertedUrl = await url();\n  } else {\n    convertedUrl = url;\n  }\n\n  const parsedUrl = optionsRef.current.fromSocketIO ?\n    parseSocketIOUrl(convertedUrl) :\n    convertedUrl;\n\n  const parsedWithQueryParams = optionsRef.current.queryParams ?\n    appendQueryParams(\n      parsedUrl,\n      optionsRef.current.queryParams\n    ) :\n    parsedUrl;\n\n  return parsedWithQueryParams;\n};\n","import { WebSocketLike } from \"./types\";\n\nexport interface SharedWebSockets {\n  [url: string]: WebSocketLike;\n}\n\nexport const sharedWebSockets: SharedWebSockets = {};\n\nexport const resetWebSockets = (url?: string): void => {\n  if (url && sharedWebSockets.hasOwnProperty(url)) {\n    delete sharedWebSockets[url];\n  } else {\n    for (let url in sharedWebSockets){\n      if (sharedWebSockets.hasOwnProperty(url)){\n        delete sharedWebSockets[url];\n      }\n    }\n  }\n}\n","import { Subscriber } from './types';\n\nexport type Subscribers = {\n    [url: string]: Set<Subscriber>,\n}\n  \nconst subscribers: Subscribers = {};\nconst EMPTY_LIST: Subscriber[] = [];\n\nexport const getSubscribers = (url: string): Subscriber[] => {\n    if (hasSubscribers(url)) {\n        return Array.from(subscribers[url]);\n    }\n    return EMPTY_LIST;\n};\n\nexport const hasSubscribers = (url: string): boolean => {\n    return subscribers[url]?.size > 0;\n};\n\nexport const addSubscriber = (url: string, subscriber: Subscriber): void => {\n    subscribers[url] = subscribers[url] || new Set<Subscriber>();\n    subscribers[url].add(subscriber);\n};\n\nexport const removeSubscriber = (url: string, subscriber: Subscriber): void => {\n    subscribers[url].delete(subscriber);\n};\n\nexport const resetSubscribers = (url?: string): void => {\n    if (url && subscribers.hasOwnProperty(url)) {\n        delete subscribers[url];\n    } else {\n        for (let url in subscribers){\n            if (subscribers.hasOwnProperty(url)){\n                delete subscribers[url];\n            }\n        }\n    }\n}\n","import { MutableRefObject } from 'react';\n\ntype IfEquals<X, Y, A=X, B=never> =\n  (<T>() => T extends X ? 1 : 2) extends\n  (<T>() => T extends Y ? 1 : 2) ? A : B;\n\ntype WritableKeys<T> = {\n  [P in keyof T]-?: IfEquals<{ [Q in P]: T[P] }, { -readonly [Q in P]: T[P] }, P>\n}[keyof T];\n\nexport const websocketWrapper = (\n  webSocket: WebSocket,\n  start: MutableRefObject<() => void>,\n): WebSocket => {\n\n  return new Proxy<WebSocket>(webSocket, {\n    get: (obj, key: keyof WebSocket) => {\n      const val = obj[key];\n      if ((key as any) === 'reconnect') return start;\n      if (typeof val === 'function') {\n        console.error('Calling methods directly on the websocket is not supported at this moment. You must use the methods returned by useWebSocket.');\n        \n        //Prevent error thrown by invoking a non-function\n        return () => {};\n      } else {\n        return val;\n      }\n    },\n    set: <T extends WritableKeys<WebSocket>>(obj: WebSocket, key: T, val: WebSocket[T]) => {\n      if (/^on/.test(key)) {\n        console.warn('The websocket\\'s event handlers should be defined through the options object passed into useWebSocket.')\n        return false;\n      } else {\n        obj[key] = val;\n        return true;\n      }\n    },\n  });\n};\n\nexport default websocketWrapper;\n","import { SOCKET_IO_PING_INTERVAL, SOCKET_IO_PATH, SOCKET_IO_PING_CODE } from './constants';\nimport { QueryParams, SendMessage } from './types';\n\nexport const parseSocketIOUrl = (url: string) => {\n  if (url) {\n    const isSecure = /^https|wss/.test(url);\n    const strippedProtocol = url.replace(/^(https?|wss?)(:\\/\\/)?/, '');\n    const removedFinalBackSlack = strippedProtocol.replace(/\\/$/, '');\n    const protocol = isSecure ? 'wss' : 'ws';\n\n    return `${protocol}://${removedFinalBackSlack}${SOCKET_IO_PATH}`;\n  } else if (url === '') {\n    const isSecure = /^https/.test(window.location.protocol);\n    const protocol = isSecure ? 'wss' : 'ws';\n    const port = window.location.port ? `:${window.location.port}` : '';\n\n    return `${protocol}://${window.location.hostname}${port}${SOCKET_IO_PATH}`;\n  }\n\n  return url;\n};\n\nexport const appendQueryParams = (url: string, params: QueryParams = {}): string => {\n  const hasParamsRegex = /\\?([\\w]+=[\\w]+)/;\n  const alreadyHasParams = hasParamsRegex.test(url);\n\n  const stringified = `${Object.entries(params).reduce((next, [key, value]) => {\n    return next + `${key}=${value}&`;\n  }, '').slice(0, -1)}`;\n\n  return `${url}${alreadyHasParams ? '&' : '?'}${stringified}`;\n};\n\nexport const setUpSocketIOPing = (sendMessage: SendMessage, interval = SOCKET_IO_PING_INTERVAL) => {\n  const ping = () => sendMessage(SOCKET_IO_PING_CODE);\n\n  return window.setInterval(ping, interval);\n};\n","import { useEffect, useRef } from 'react'\nimport { useWebSocket } from './use-websocket'\nimport { DEFAULT_EVENT_SOURCE_OPTIONS, EMPTY_EVENT_HANDLERS } from './constants'\nimport { EventSourceOptions, Options, EventSourceHook, EventSourceEventHandlers } from './types';\n\nexport const useEventSource = (\n  url: string | (() => string | Promise<string>) | null,\n  { withCredentials, events, ...options }: EventSourceOptions = DEFAULT_EVENT_SOURCE_OPTIONS,\n  connect: boolean = true,\n): EventSourceHook => {\n  const optionsWithEventSource: Options = {\n      ...options,\n      eventSourceOptions: {\n        withCredentials,\n      }\n  };\n  const eventsRef = useRef<EventSourceEventHandlers>(EMPTY_EVENT_HANDLERS);\n  if (events) {\n    eventsRef.current = events\n  }\n\n  const {\n    lastMessage,\n    readyState,\n    getWebSocket,\n  } = useWebSocket(\n    url,\n    optionsWithEventSource,\n    connect,\n  );\n\n  useEffect(() => {\n    if (lastMessage?.type) {\n        Object.entries(eventsRef.current).forEach(([type, handler]) => {\n            if (type === lastMessage.type) {\n                handler(lastMessage);\n            }\n        });\n    }\n  }, [lastMessage]);\n\n  return {\n    lastEvent: lastMessage,\n    readyState,\n    getEventSource: getWebSocket,\n  };\n}\n","import { useMemo } from 'react'\nimport { useWebSocket } from './use-websocket'\nimport { DEFAULT_OPTIONS } from './constants'\nimport { Options, WebSocketHook } from './types';\n\nexport interface SocketIOMessageData<T = unknown> {\n  type: string,\n  payload: T | null,\n}\n\nconst emptyEvent: SocketIOMessageData<null> = {\n  type: 'empty',\n  payload: null,\n}\n\nconst getSocketData = <T = unknown>(event: WebSocketEventMap['message'] | null): SocketIOMessageData<T | null> => {\n  if (!event || !event.data) {\n    return emptyEvent\n  }\n\n  const match = event.data.match(/\\[.*]/)\n\n  if (!match) {\n    return emptyEvent\n  }\n\n  const data = JSON.parse(match)\n\n  if (!Array.isArray(data) || !data[1]) {\n    return emptyEvent\n  }\n\n  return {\n    type: data[0],\n    payload: data[1],\n  }\n}\n\nexport const useSocketIO = <T = unknown>(\n  url: string | (() => string | Promise<string>) | null,\n  options: Options = DEFAULT_OPTIONS,\n  connect: boolean = true,\n): WebSocketHook<SocketIOMessageData<T | null>, SocketIOMessageData<T | null>> => {\n  const optionsWithSocketIO = useMemo(() => ({\n    ...options,\n    fromSocketIO: true,\n  }), [])\n\n  const {\n    sendMessage,\n    sendJsonMessage,\n    lastMessage,\n    readyState,\n    getWebSocket,\n  } = useWebSocket(\n\n    url,\n    optionsWithSocketIO,\n    connect,\n  );\n\n  const socketIOLastMessage = useMemo(() =>\n    getSocketData<T>(lastMessage), [lastMessage]);\n\n  return {\n    sendMessage,\n    sendJsonMessage,\n    lastMessage: socketIOLastMessage,\n    lastJsonMessage: socketIOLastMessage,\n    readyState,\n    getWebSocket,\n  };\n}\n","import { useEffect, useRef, useState, useCallback, useMemo } from 'react';\nimport { flushSync } from 'react-dom';\nimport { DEFAULT_OPTIONS, isEventSourceSupported, ReadyState, UNPARSABLE_JSON_OBJECT } from './constants';\nimport { createOrJoinSocket } from './create-or-join';\nimport { getUrl } from './get-url';\nimport websocketWrapper from './proxy';\nimport {\n  Options,\n  ReadyStateState,\n  SendMessage,\n  SendJsonMessage,\n  WebSocketMessage,\n  WebSocketHook,\n  WebSocketLike,\n} from './types';\nimport { assertIsWebSocket } from './util';\n\nexport const useWebSocket = <T = unknown>(\n  url: string | (() => string | Promise<string>) | null,\n  options: Options = DEFAULT_OPTIONS,\n  connect: boolean = true,\n): WebSocketHook<T> => {\n  const [lastMessage, setLastMessage] = useState<WebSocketEventMap['message'] | null>(null);\n  const [readyState, setReadyState] = useState<ReadyStateState>({});\n  const lastJsonMessage: T = useMemo(() => {\n    if (lastMessage) {\n      try {\n        return JSON.parse(lastMessage.data);\n      } catch (e) {\n        return UNPARSABLE_JSON_OBJECT;\n      }\n    }\n    return null; \n  },[lastMessage]);\n  const convertedUrl = useRef<string | null>(null);\n  const webSocketRef = useRef<WebSocketLike | null>(null);\n  const startRef = useRef<() => void>(() => void 0);\n  const reconnectCount = useRef<number>(0);\n  const messageQueue = useRef<WebSocketMessage[]>([]);\n  const webSocketProxy = useRef<WebSocketLike | null>(null);\n  const optionsCache = useRef<Options>(options);\n  optionsCache.current = options;\n\n  const readyStateFromUrl: ReadyState =\n    convertedUrl.current && readyState[convertedUrl.current] !== undefined ?\n      readyState[convertedUrl.current] :\n      url !== null && connect === true ?\n        ReadyState.CONNECTING :\n        ReadyState.UNINSTANTIATED;\n\n  const stringifiedQueryParams = options.queryParams ? JSON.stringify(options.queryParams) : null;\n\n  const sendMessage: SendMessage = useCallback((message, keep = true) => {\n    if (isEventSourceSupported && webSocketRef.current instanceof EventSource) {\n      console.warn('Unable to send a message from an eventSource');\n      return;\n    }\n  \n    if (webSocketRef.current?.readyState === ReadyState.OPEN) {\n      assertIsWebSocket(webSocketRef.current, optionsCache.current.skipAssert);\n      webSocketRef.current.send(message);\n    } else if (keep) {\n      messageQueue.current.push(message);\n    }\n  }, []);\n\n  const sendJsonMessage: SendJsonMessage = useCallback((message, keep = true) => {\n    sendMessage(JSON.stringify(message), keep);\n  }, [sendMessage]);\n  \n  const getWebSocket = useCallback(() => {\n    if (optionsCache.current.share !== true || (isEventSourceSupported && webSocketRef.current instanceof EventSource)) {\n      return webSocketRef.current;\n    }\n\n    if (webSocketProxy.current === null && webSocketRef.current) {\n      assertIsWebSocket(webSocketRef.current, optionsCache.current.skipAssert);\n      webSocketProxy.current = websocketWrapper(webSocketRef.current, startRef);\n    }\n\n    return webSocketProxy.current;\n  }, []);\n\n  useEffect(() => {\n    if (url !== null && connect === true) {\n      let removeListeners: () => void;\n      let expectClose = false;\n      let createOrJoin = true;\n\n      const start = async () => {\n        convertedUrl.current = await getUrl(url, optionsCache);\n\n        const protectedSetLastMessage = (message: WebSocketEventMap['message']) => {\n          if (!expectClose) {\n            flushSync(() => setLastMessage(message));\n          }\n        };\n  \n        const protectedSetReadyState = (state: ReadyState) => {\n          if (!expectClose) {\n            flushSync(() => setReadyState(prev => ({\n              ...prev,\n              ...(convertedUrl.current && {[convertedUrl.current]: state}),\n            })));\n          }\n        };\n\n        if(createOrJoin) {\n          removeListeners = createOrJoinSocket(\n            webSocketRef,\n            convertedUrl.current,\n            protectedSetReadyState,\n            optionsCache,\n            protectedSetLastMessage,\n            startRef,\n            reconnectCount,\n            sendMessage,\n          );\n        }\n      };\n\n      startRef.current = () => {\n        if (!expectClose) {\n          if (webSocketProxy.current) webSocketProxy.current = null;\n          removeListeners?.();\n          start();\n        }\n      };\n    \n      start();\n      return () => {\n        expectClose = true;\n        createOrJoin = false;\n        if (webSocketProxy.current) webSocketProxy.current = null;\n        removeListeners?.();\n        setLastMessage(null);\n      };\n    } else if (url === null || connect === false) {\n      reconnectCount.current = 0; // reset reconnection attempts\n      setReadyState(prev => ({\n        ...prev,\n        ...(convertedUrl.current && {[convertedUrl.current]: ReadyState.CLOSED}),\n      }));\n    }\n  }, [url, connect, stringifiedQueryParams, sendMessage]);\n\n  useEffect(() => {\n    if (readyStateFromUrl === ReadyState.OPEN) {\n      messageQueue.current.splice(0).forEach(message => {\n        sendMessage(message);\n      });\n    }\n  }, [readyStateFromUrl]);\n\n  return {\n    sendMessage,\n    sendJsonMessage,\n    lastMessage,\n    lastJsonMessage,\n    readyState: readyStateFromUrl,\n    getWebSocket,\n  };\n};\n","import { WebSocketLike } from './types';\nimport { resetWebSockets } from './globals';\nimport { resetSubscribers } from './manage-subscribers';\n\nexport function assertIsWebSocket (\n    webSocketInstance: WebSocketLike,\n    skip?: boolean,\n): asserts webSocketInstance is WebSocket {\n    if (!skip && webSocketInstance instanceof WebSocket === false) throw new Error('');\n};\n\n\nexport function resetGlobalState (url?: string): void {\n    resetSubscribers(url);\n    resetWebSockets(url);\n};\n"],"names":["socketUrl","window","location","origin","replace","console","log","useWebSocket","share","retryOnError","reconnectAttempts","reconnectInterval","shouldReconnect","onOpen","event","onClose","closeEvent","onError","errEvent","onReconnectStop","numAttemp","sendMessage","lastMessage","readyState","useState","binanceHeatmap","$binanceHeatmap","useEffect","json","JSON","parse","data","stringify","message","className","change24Hs","slice","map","contract","idx","symbol","priceChangePercent","tradingVol24H","quoteVolume","fundingRates","fundingRate","Object","enumerable","get","exports","webSocketInstance","setters","optionsRef","reconnect","reconnectCount","interval","cancelReconnectOnClose","cancelReconnectOnError","setLastMessage","setReadyState","current","fromSocketIO","setUpSocketIOPing","onmessage","onMessage","filter","bindMessageHandler","onopen","constants_1","OPEN","bindOpenHandler","EventSource","assertIsWebSocket","skipAssert","onclose","CLOSED","nextReconnectInterval","reconnectTimeout","setTimeout","warn","clearTimeout","bindCloseHandler","onerror","error","code","reason","wasClean","close","bindErrorHandler","CLOSING","clearInterval","url","getSubscribers","forEach","subscriber","WebSocket","globals_1","withCredentials","events","ReadyState","navigator","product","globalThis","e","eventSourceSupported","webSocketRef","startRef","eventSourceOptions","Error","clearSocketIoPingInterval","undefined","protocols","CONNECTING","attachSharedListeners","addSubscriber","removeSubscriber","hasSubscribers","socketLike","cleanSubscribers","attachListeners","convertedUrl","_a","parsedUrl","parseSocketIOUrl","queryParams","appendQueryParams","hasOwnProperty","url_1","subscribers","EMPTY_LIST","Array","from","size","Set","add","delete","webSocket","start","Proxy","obj","key","val","set","test","isSecure","removedFinalBackSlack","protocol","port","hostname","params","alreadyHasParams","stringified","entries","reduce","next","value","setInterval","connect","options","optionsWithEventSource","eventsRef","useRef","getWebSocket","type","handler","lastEvent","getEventSource","emptyEvent","payload","optionsWithSocketIO","useMemo","sendJsonMessage","socketIOLastMessage","match","isArray","getSocketData","lastJsonMessage","messageQueue","webSocketProxy","optionsCache","readyStateFromUrl","UNINSTANTIATED","stringifiedQueryParams","useCallback","keep","send","push","removeListeners_1","expectClose_1","createOrJoin_1","start_1","getUrl","_b","protectedSetLastMessage","flushSync","protectedSetReadyState","state","prev","createOrJoinSocket","splice","skip","resetSubscribers","resetWebSockets"],"sourceRoot":""}